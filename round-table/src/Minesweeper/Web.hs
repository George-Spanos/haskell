{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}


module Minesweeper.Web
  ( runWebApp,
  )
where

import qualified Control.Applicative as App -- Qualified import for alternative parsing
import qualified Data.Aeson as Aeson
import Data.Aeson ((.=), (.:)) -- Explicitly import operators and functions
import qualified Data.Aeson.Key as Key -- Import Key module
import qualified Data.Aeson.KeyMap as KeyMap -- Import KeyMap for toList
import qualified Data.Aeson.Types as AesonTypes (Parser, Pair, parseMaybe) -- Import specific types/functions
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Map.Strict as Map

-- Import from scotty directly instead of Control.Monad.Catch
import Minesweeper.Game
import Network.Wai.Middleware.Static
import System.Random (randomIO)
import Text.Blaze.Html.Renderer.Text
import qualified Text.Blaze.Html5 as H
import qualified Text.Blaze.Html5.Attributes as A
import Web.Scotty -- Keep Scotty's catch
import Web.Scotty.Internal.Types (ActionError(..))

-- Run the web application
runWebApp :: Int -> IO ()
runWebApp port = do
  -- Create default game state with a random seed
  initialSeed <- randomIO
  let initialGame = newGame 10 10 15 initialSeed

  scotty port $ do
    -- Serve static files
    middleware $ staticPolicy (addBase "static")

    -- Home page
    get "/" $ do
      html $ renderHtml gamePage

    -- API routes
    get "/api/game" $ do
      json $ gameToJson initialGame

    post "/api/game/new" $ do
      width <- formParam "width" `catch` (\(_ :: ActionError) -> return 10)
      height <- formParam "height" `catch` (\(_ :: ActionError) -> return 10)
      mineCount <- formParam "mines" `catch` (\(_ :: ActionError) -> return 15)

      gameSeed <- liftIO randomIO
      let newGameState = newGame width height mineCount gameSeed

      json $ gameToJson newGameState

    post "/api/game/reveal" $ do
      x <- formParam "x"
      y <- formParam "y"
      gameJsonText <- formParam "game" :: ActionM TL.Text

      let maybeGameJson = Aeson.decode (TL.encodeUtf8 gameJsonText)
          maybeGame = maybeGameJson >>= jsonToGame
      case maybeGame of
          Just game -> do
              let newGameState = revealCell (x, y) game
              json $ gameToJson newGameState
          Nothing ->
              json $ Aeson.object ["error" .= ("Invalid game state" :: String)]

    post "/api/game/flag" $ do
      x <- formParam "x"
      y <- formParam "y"
      gameJsonText <- formParam "game" :: ActionM TL.Text

      let maybeGameJson = Aeson.decode (TL.encodeUtf8 gameJsonText)
          maybeGame = maybeGameJson >>= jsonToGame
      case maybeGame of
          Just game -> do
              let newGameState = flagCell (x, y) game
              json $ gameToJson newGameState
          Nothing ->
              json $ Aeson.object ["error" .= ("Invalid game state" :: String)]

-- HTML for the game page
gamePage :: H.Html
gamePage = H.docTypeHtml $ do
    H.head $ do
        H.meta H.! A.charset "UTF-8"
        H.meta H.! A.name "viewport" H.! A.content "width=device-width, initial-scale=1.0"
        H.title "Haskell Minesweeper"
        -- Link to external CSS file
        H.link H.! A.rel "stylesheet" H.! A.href "/css/minesweeper.css"
    H.body $ do
        -- Restore div content and fix syntax error
        H.div H.! A.class_ "container" $ do
            H.h1 "Haskell Minesweeper"
            H.div H.! A.class_ "controls" $ do
                H.button H.! A.id "new-game" $ "New Game"
                H.span H.! A.id "mine-counter" $ "Mines: 0" -- Placeholder, JS updates this
                H.span H.! A.id "game-status" $ "In Progress" -- Placeholder, JS updates this
            H.div H.! A.id "board" $ "" -- Board content generated by JS
        -- Link to external JavaScript file
        H.script H.! A.src "/js/minesweeper.js" $ ""

-- Convert game state to JSON
gameToJson :: GameState -> Aeson.Value
gameToJson game = Aeson.object
    [ "width" .= boardWidth game
    , "height" .= boardHeight game
    , "mineCount" .= length (mines game)
    , "status" .= gameStatusToJson (gameStatus game)
    , "revealedCount" .= revealedNonMineCount game  -- Add the new field
    , "cells" .= Aeson.object (map cellToJson $ Map.toList $ gameBoard game)
    ]
  where
    cellToJson :: (Position, CellState) -> AesonTypes.Pair
    cellToJson ((x, y), state) =
        (Key.fromString $ show x ++ "," ++ show y) .= cellStateToJson state

    cellStateToJson :: CellState -> Aeson.Value
    cellStateToJson Hidden = Aeson.object ["type" .= ("hidden" :: String)]
    cellStateToJson Flagged = Aeson.object ["type" .= ("flagged" :: String)]
    cellStateToJson (Revealed count) = Aeson.object ["type" .= ("revealed" :: String), "adjacentMines" .= count]
    cellStateToJson RevealedMine = Aeson.object ["type" .= ("mine" :: String)]

    gameStatusToJson :: GameStatus -> String
    gameStatusToJson InProgress = "in-progress"
    gameStatusToJson Won = "won"
    gameStatusToJson Lost = "lost"

-- Convert JSON to game state
jsonToGame :: Aeson.Value -> Maybe GameState
jsonToGame = AesonTypes.parseMaybe $ Aeson.withObject "GameState" $ \obj -> do
    width <- obj .: "width"
    height <- obj .: "height"
    mineCount <- obj .: "mineCount"
    statusStr <- obj .: "status"
    cellsObj <- obj .: "cells"
    
    -- Optional: try to get the revealed count from JSON, or default to calculating it
    revealedCount <- (obj .: "revealedCount") App.<|> return 0

    -- Create a new game state with a fixed seed (42)
    -- This ensures mines are consistent when state is sent back to server
    let game = newGame width height mineCount 42
        gameStatus' = jsonToGameStatus statusStr
    
    -- Now update the board with the cell states from JSON
    board' <- jsonToBoardMap cellsObj
    
    -- Calculate the actual revealed count if not provided in JSON
    let actualRevealedCount = if revealedCount > 0 
                              then revealedCount 
                              else countRevealed board'
    
    return $ game
        { gameBoard = board'
        , gameStatus = gameStatus'
        , revealedNonMineCount = actualRevealedCount
        }
  where
    jsonToGameStatus :: String -> GameStatus
    jsonToGameStatus "in-progress" = InProgress
    jsonToGameStatus "won" = Won
    jsonToGameStatus "lost" = Lost
    jsonToGameStatus _ = InProgress
    
    -- Count revealed non-mine cells in the board
    countRevealed :: Map.Map Position CellState -> Int
    countRevealed brd = length $ filter isRevealed $ Map.elems brd
      where
        isRevealed (Revealed _) = True
        isRevealed _ = False

    -- Function to parse just the board map from the cells object
    jsonToBoardMap :: Aeson.Value -> AesonTypes.Parser (Map.Map Position CellState)
    jsonToBoardMap = Aeson.withObject "cells" $ \cellsObj -> do
        let parsePos :: String -> Maybe Position
            parsePos s = case break (==',') s of
                (xStr, ',':yStr) -> Just (read xStr, read yStr)
                _ -> Nothing

            parseCell :: Aeson.Value -> AesonTypes.Parser CellState
            parseCell = Aeson.withObject "cell" $ \cell -> do
                typeStr <- cell .: "type"
                case typeStr :: String of
                    "hidden" -> return Hidden
                    "flagged" -> return Flagged
                    "revealed" -> do
                        count <- cell .: "adjacentMines"
                        return (Revealed count)
                    "mine" -> return RevealedMine
                    _ -> fail "Unknown cell type"

        -- Parse all cells
        parsedCells <- mapM
            (\(key, val) -> do
                -- Parse position from key
                pos <- case parsePos (Key.toString key) of
                           Just p -> return p
                           Nothing -> fail $ "Invalid position key: " ++ Key.toString key
                -- Parse cell state
                state <- parseCell val
                return (pos, state)
            )
            (KeyMap.toList cellsObj)

        -- Return the board map
        return (Map.fromList parsedCells)